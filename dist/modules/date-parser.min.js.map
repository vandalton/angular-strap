{"version":3,"sources":["modules/date-parser.js"],"names":["angular","this","seconds","provider","$localeProvider","milliseconds","year","ParseDate","prototype","hours","value","noop","array","toLowerCase","isNaN","i","indexOfCaseInsensitive","defaults","len","length","str","toString","format","strict","minutes","day","month","getFullYear","getHours","getMilliseconds","getMonth","Date","getMinutes","proto","isNumeric","toDate","$dateParser","regExpMap","sss","$get","options","$locale","dateFilter","mm","config","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","split","dateRegexParts","forEach","escapeReservedSymbols","text","join","replace","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","init","setFnMap","DateParserFactory","setMap","m","extend","HH","H","hh","h","a","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","setSeconds","s","setMinutes","setHours","setDate","setMonth","match","setFullYear","regex","$format","regExpForFormat","test","baseDate","formatRegex","formatSetMap","matches","date","getTime","timezone","newDate","parseInt","fromDate","call","getDate","substr","today","key","Infinity","getTimeForAttribute","time","daylightSavingAdjust","parse","timezoneOffsetAdjust","undo","getTimezoneOffset"],"mappings":"AAOA,YAEAA,SAKIC,OAAKC,wCAAUC,SAAA,eAAA,kBAAA,SAAAC,GAJjB,QAKOC,KAJLJ,KAAKK,KAAO,KAOdC,KAAAA,MAAUC,EAA+CP,KAAKI,IAAAA,EAJ5DJ,KAAKQ,MAAQ,EAKfF,KAAAA,QAAUC,EAA0CP,KAAKC,QAAUQ,EAFjET,KAAKI,aAAe,EAwCtB,QAJOM,MAKP,QAJQC,GAASC,GAKf,OALwCC,MAAOC,WAAAA,KAAAA,SAAAA,GAOjD,QAASC,GAAuBJ,EAAOF,GAFvC,IAAIO,GAHFC,GAAQN,EAAAO,OAOJC,EAAMV,EAAMW,WAAWR,cAJzBI,EAAWhB,EAAAA,EAAKgB,EAAAA,IAClBK,GAAAA,EAAQP,GAAAF,gBAAAO,EACRG,MAAQR,EAKR,UA/CFR,EACyDiB,UAAUd,gBAAAA,SAAAA,GAAjET,KAAKI,aAAeK,GAEtBH,EADuDE,UAAQC,WAAAA,SAAAA,GAE7DT,KAAKC,QAAUQ,GAEjBH,EAHoDN,UAAKQ,WAAAA,SAAAA,GAIvDR,KAAKuB,QAAUd,GAEjBH,EALsDkB,UAAMf,SAAAA,SAAAA,GAM1DT,KAAKQ,MAAQC,GAEfH,EAPuDmB,UAAQhB,SAAAA,WAQ7D,MAAOT,MAAKQ,OAEdF,EAT0DD,UAAOI,QAAAA,SAAAA,GAU/DT,KAAKwB,IAAMf,GAEbH,EAVOD,UAAaqB,SAAAA,SAAAA,GAClB1B,KAAKyB,MAAQhB,GAYfH,EAVOE,UAAQC,YAAMkB,SAAAA,GACnB3B,KAAKuB,KAAAA,GAYPjB,EAVOF,UAAAA,SAAqBwB,SAAAA,GAa5B,MAZE5B,MAAAK,KAAOL,EAAAA,cAWPA,KAAKyB,MAAQhB,EAAMoB,WARrBvB,KAAAA,IAAUC,EAAAA,UACRP,KAAAQ,MAAWsB,EAAK9B,WAUhBA,KAAKuB,QAAUd,EAAMsB,aAPvB/B,KAAIgC,QAAQ1B,EAAUC,aAEtBP,KAAAI,aAASM,EAAAA,kBAGAuB,MAOT3B,EAAUC,UAAU2B,OAAS,WAH7B,MAASnB,IAAAA,MAAAA,KAAAA,KAAAA,KAAwBJ,MAAOF,KAAAA,IAAAA,KAAAA,MAAAA,KAAAA,QAAAA,KAAAA,QAAAA,KAAAA,cAMxC,IAJEuB,GAAUvB,EAAMW,UAkBdJ,EAAImB,KAAAA,UAENd,OACMe,YAANd,QACIe,EACNrC,MAAKsC,MACWC,UAAQjB,aAAS,SAAgBkB,EAAAC,GAA/C,GACIC,GAAU,SAAAC,GA+IZ,QAgCMC,GAAevB,GACnB,GAAIwB,GAAAA,EAAcC,EAClB,OAAIC,GAAsBC,GA9B5B,QAiCEjD,GAA6BsB,GAhC7B,GAiCE4B,GAAIC,EAA6B7B,GAC/B8B,EAAOC,EAAuBD,QAAAA,MAAAA,QAhC9BP,EAiCK,kBAELC,EAAaC,EAAoB5B,MAAQJ,GAjCzCiC,EAkCcM,OAAMN,KAAAA,GAjCpBO,IAWJ,OAVAvD,SAAQwD,QAAQV,EAAa,SAASM,GAmCpCG,GAAAA,EAAoBH,GAjClBA,EAAOC,EAAuBD,OAE9B,KAAK,GAAIrC,GAAI,EAAGA,EAAIiC,EAAa7B,OAAQJ,IAqC/CqC,EAASK,EAAAA,MAAAA,EAAuBC,IAAAA,KAAAA,KAAAA,EAAAA,IAahCH,GAASJ,KAAAA,KA5CAI,EAAeI,KAAK,IAE7B,QA+CSD,GAAaA,GA9CpB,MAAOA,GAAKE,QAAQ,MAAO,UAAUA,QAAQ,KAAM,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,OAAQ,SAEtO,QAgDMZ,GAAsBC,GAC1B,MAAIY,SAAKC,KAAAA,GA9CX,QAkDSD,GAAoBH,GAjD3B,MAAOA,GAAKE,QAAQ,WAAY,MAElC,QAASG,GAAoBD,GAuD3B,IAAA,GAFFd,GAASgB,OAAiB1C,KAAAA,GACpBuC,EAAKI,EACFC,EAAAA,EAAAA,EAAAA,EAAwBL,OAAAA,IAnD7BA,EAAKA,EAAGP,MAAM,KAAOvC,EAAI,KAAK4C,KAAK,IAAMtB,EAAUW,EAAajC,IAAM,IAuDxE,OAAIiC,IAAAA,QAAAA,IAAemB,EAAOlB,KAAKZ,MAnDjC,QAqDM+B,GAAAA,GACJ,GAAIC,GAAAA,EAAAA,EACJ,OAAIC,GAAAA,GAnDN,QAqDMC,GAAAA,GA7CJ,IAgDA,GAEED,GACAE,EAEAD,EAvDEC,EAkDJxB,EAAQoB,OAAcK,KAAAA,GACpBJ,EAAWD,GAAAA,QAAY,cAAA,KAOzBG,KAxD2D,QAAnDH,EAAcK,EAAYC,KAAKZ,KA2DzC1B,EAAYuC,EAAAA,GACZL,EAAOlC,EAAAA,GAzDHoC,EAAgBI,EAASN,GA6D/BC,EAAOM,KAAAA,EA1DH,OAAON,GAzMT,GAsDAnC,GACE0C,EAtDAC,EAAkBxD,QAASyD,UAAA/D,EAAgB2B,GAC3CqC,KACAC,GACAC,IAAU,WACVC,GAAU5C,aACV6C,EAAU7C,EAAAjB,OAAA,cAAA,mBACV+D,GAAAA,aACAC,EAAAA,EAAU9C,OAAQ+C,cAAiBC,mBACnCC,GAAU,mBACVC,EAAUnD,EAAQjB,OAAS,iBAAA,oBAC3BqE,GAAAA,oBACAC,EAAAA,EAAUpD,OAAQ+C,eAAiBM,iBACnCC,EAAAA,QACAC,KAAUxD,EAAQjB,iBAAS0E,IAAAtC,KAAiB,KAC5CuC,IAAAA,EAAUV,iBAAAC,SAAA9B,KAAA,KACVwC,GAAU,yBACVC,EAAU5D,EAAQjB,OAAS,yBAA0B,2BAArDqE,KAAMnD,EAAQ+C,iBAAiBa,MAAM1C,KAAK,KAG5CkC,IAAIjB,EAAAA,iBAAAA,WAAAA,KAAAA,KACFtC,GAAAA,gBACAgE,EAAAA,EAAgBC,OAAAA,eAAAA,iBAChBC,KAAUvE,gCACVU,GAAUV,WACV8C,EAAU9C,EAAMwE,OAAAA,wBAAAA,kBAEhBvB,GACAC,IAAUlD,EAAMyE,gBAChBtB,GAAUnD,EAAMyE,WAChBpB,EAAAA,EAAU3E,WACV4E,GAAAA,EAAU5E,WACV+E,EAAAA,EAAUzD,WACV0D,GAAU1D,EAAM0E,SAChBtB,EAAUpD,EAAAyE,SADVvB,GAC6BlD,EAAIxB,SAAjC2E,EAA+DnD,EAAOhC,SACtEqF,KAAM3E,EAANiF,IAAAA,EAEAF,GAF6BzD,EAAOhC,QAGpC0F,EAAG1D,EAAM0E,QAFTd,EAAAA,SAAUnF,GAAmB,GAAAD,GAAYmG,KAAAA,WAAS5F,EAKhD,OAAOf,MAAKyG,SAAShG,EAAMmG,MAAM,OAASpG,EAAQ,GAAKA,IAEzDmF,KAN6B,SAAYgB,GAOvC,MAAO3G,MAAK2G,SAAS5F,EAAuByB,EAAQ+C,iBAAiBa,MAAO3F,KAE9EmF,IAR6B,SAAYe,GASvC,MAAO3G,MAAK2G,SAAS5F,EAAuByB,EAAQ+C,iBAAiBM,WAAYpF,KAPnFyF,GAAU,SAAUzF,GAAS,MAAOT,MAAK6G,SAAAA,EAAYpG,EAAO,IAC5D0F,EAAU,SAAU1F,GAAS,MAAQT,MAAIS,SAAS,EAAAA,EAAYS,IAc9D+E,KAAMjE,EAAM6E,YAVdX,GAAIY,SAAAA,GACAjC,MAAAA,MAAAA,YAAAA,IAAAA,EAAAA,IAGF1C,EAAAA,SAAY4E,GACZD,MAAQE,GAAAA,GAAAA,IAA4BD,IAAZ5E,EAAAA,OAAY4E,KAAAA,YAAAA,IAAAA,EAAAA,GAAAA,KAAAA,YAAAA,EAAAA,IA0JtC,OA3IA5E,GATS2E,KAAMG,WAUb9E,EAAY4E,QAAUvE,EAAQ+C,iBAAiBhD,EAAQlB,SAAWkB,EAAQlB,OAP5Ec,EAAAA,EAAoBA,EAAiB+E,SAEnCrC,EAAIxD,EAAiBmB,EAAQ+C,UAS/BpD,EAPMgF,QAAc9F,SAAS2F,GAC3B,MAAII,SAAAA,OAAe/F,IAAS0C,MAAAA,EAAgB1C,WACxCgG,EAAAA,KAAUF,IAShBhF,EANMmF,MAAOJ,SAAarG,EAAMqG,EAASK,EAAaC,GACpDnG,IAASP,EAAWuG,EAAQnG,iBAAiBG,IAAAA,GAC3CtB,QAAIqH,OAAatG,KAAIsG,EAAAA,EAAqBE,EAAMD,GAAYlF,EAAA4E,QAAAS,GAO9D,IAAIL,GAAc9F,EAAS2F,EAAgB3F,GAAUyF,EAJjDW,EAAevF,EAAAA,EAAAA,GAAAA,EAGfwF,EAASJ,EAAU7C,KAAQgD,EAI/B,KAHEJ,EAAO,OAAA,CAGT,KAAA,GACIC,GAAOJ,IAAarG,MAAMqG,EAASK,YAAa,GAAIjH,IAAYqH,SAAST,IAAY,GAAI5G,IAAYqH,SAAS,GAAI7F,MAAK,KAAM,EAAG,EAAG,IADhI2F,EAAAA,EAAAA,EAAAA,EAAAA,OAAAA,EAAAA,IAGDL,EAAatG,IAAIsG,EAAatG,GAAG8G,KAAKN,EAAMD,EAAQvG,EAAI,GAC9D,IAAIwG,GAAAA,EAAAA,QAEJ,OAAI7G,UAAAA,EAAUe,IAAS,MAAAiG,EAAAI,WAGhBJ,GAETtF,EAAMmF,oBAAsBQ,SAAUrH,EAAMS,GAC1C,GAAIoG,EACJ,IAAW,UAAPA,EAAgB7G,CAClB,GAAIsH,GAAQ,GAAIjG,KAChBwF,GAAK,GAAIrF,MAAAA,EAAUxB,cAAQsH,EAAAlG,WAAAkG,EAAAF,WAAA,YAAAG,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,YAAAA,EAAA,UAG3BV,GAFOvH,QAAS2H,SAASjH,IAAOA,EAAAmG,MAAA,UAC5BnG,EAAKV,MAAAA,KACFiI,GAAAA,MAAQvH,EAAAqH,OAAaG,EAAAA,EAAYA,OAAAA,IAEjC,GAAInG,MAAKrB,EAAAA,OAAAA,EAAAA,EAAAA,OAAAA,IAGX6G,EAAAA,GAAE,GAAIxF,MAAK4F,SAASjH,EAAO,KAGxByH,QAAAA,SAAAA,IAAqCzH,IAAfA,EAAUuH,OACtCG,YAAAA,IAAAA,EAAAA,KAAAA,EAAAA,GAGK,GAAIrG,MAAAA,EADb,OAGEqG,IADJhG,EAGW+F,oBAAkBzH,SAAYoG,EAAAA,GAFvC,GAAIsB,EA0BJ,OAxBEA,GAEOH,QAAPG,GACK,GAAArG,OAAA+E,YAAA,KAAA,EAAA,GACE1E,QAAAA,SAAkB1B,IAAWqB,EAAK8E,MAAM,UAFxC,GAAI9E,MAAKrB,EAAMqH,OAAO,EAAGrH,EAAMS,OAAS,IAAI2F,YAAY,KAAM,EAAG,GAKnEsB,EAAAA,GAHE,GAAIrG,MAAK4F,SAASjH,EAAO,KAAKoG,YAAY,KAAM,EAAG,GAelDuB,QAAAA,SAAAA,IAAiCd,IAAV7G,EAAU6G,OAChC,YAANA,IAAMW,EAAAA,KAAAA,EAAAA,GAZF9F,EAAYkG,MAAM5H,EAAO,GAAIqB,MAAK,KAAM,EAAG,EAAG,KAyBzDK,EAAYmG,qBAAuB,SAAUhB,GAC3C,MAAKA,IAILA,EAAIE,SAAAA,EAAYA,WAAa,GAAOF,EAAA3F,WAAA,EAAA,GAClC2F,GAJO,MAhBXnF,EAAYmG,qBAAuB,SAAShB,EAAME,EAAUe,GAuB1D,MAAAjB,IAYI1D,GAAKI,QAAAA,IACTsD,EAAOxD,GAAAA,MAAAA,EAAAA,WA9BLwD,EAAKd,WAAWc,EAAKvF,cAAgBwG,KAAY,GAAKjB,EAAKkB,sBAkCzDvF,GAtCK,MAoEXd,EAAYuC,OACLvC,EAET,OAAOyC","file":"date-parser.min.js","sourcesContent":["'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function ($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate () {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function () { return this.hours; };\r\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function (value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function () {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop () {\r\n  }\r\n\r\n  function isNumeric (n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive (array, value) {\r\n    var len = array.length;\r\n    var str = value.toString().toLowerCase();\r\n    for (var i = 0; i < len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function ($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function (config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      /* eslint-disable key-spacing, quote-props */\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\r\n      };\r\n      /* eslint-enable key-spacing, quote-props */\r\n\r\n      var regex;\r\n      var setMap;\r\n\r\n      $dateParser.init = function () {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function (date) {\r\n        if (angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function (value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if (!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for (var i = 0; i < matches.length - 1; i++) {\r\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function (key, value) {\r\n        var date;\r\n\r\n        if (value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          if (value.match(/Z/)) {\r\n            date = new Date(value.substr(1, value.length - 3));\r\n          } else {\r\n            date = new Date(value.substr(1, value.length - 2));\r\n          }\r\n        } else if (isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function (key, value) {\r\n        var time;\r\n\r\n        if (value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if (isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function (date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function regExpForFormat (format) {\r\n        // `format` string can contain literal values.\r\n        // These need to be escaped by surrounding with\r\n        // single quotes (e.g. `\"h 'in the morning'\"`).\r\n        // In order to output a single quote, escape it - i.e.,\r\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\r\n\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseRegex(re);\r\n      }\r\n\r\n      function buildDateAbstractRegex (format) {\r\n        var escapedFormat = escapeReservedSymbols(format);\r\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\r\n        var literalRegex = /('(?:\\\\'|.)*?')/;\r\n        var formatParts = escapedLiteralFormat.split(literalRegex);\r\n        var dateElements = Object.keys(regExpMap);\r\n        var dateRegexParts = [];\r\n\r\n        angular.forEach(formatParts, function (part) {\r\n          if (isFormatStringLiteral(part)) {\r\n            part = trimLiteralEscapeChars(part);\r\n          } else {\r\n            // Abstract replaces to avoid collisions\r\n            for (var i = 0; i < dateElements.length; i++) {\r\n              part = part.split(dateElements[i]).join('${' + i + '}');\r\n            }\r\n          }\r\n          dateRegexParts.push(part);\r\n        });\r\n\r\n        return dateRegexParts.join('');\r\n      }\r\n\r\n      function escapeReservedSymbols (text) {\r\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\r\n                   .replace(/-/g, '[-]')\r\n                   .replace(/\\./g, '[.]')\r\n                   .replace(/\\*/g, '[*]')\r\n                   .replace(/\\+/g, '[+]')\r\n                   .replace(/\\?/g, '[?]')\r\n                   .replace(/\\$/g, '[$]')\r\n                   .replace(/\\^/g, '[^]')\r\n                   .replace(/\\//g, '[/]')\r\n                   .replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function isFormatStringLiteral (text) {\r\n        return /^'.*'$/.test(text);\r\n      }\r\n\r\n      function trimLiteralEscapeChars (text) {\r\n        return text.replace(/^'(.*)'$/, '$1');\r\n      }\r\n\r\n      function buildDateParseRegex (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var re = abstractRegex;\r\n\r\n        // Replace abstracted values\r\n        for (var i = 0; i < dateElements.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\r\n        }\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      function setMapForFormat (format) {\r\n        var re = buildDateAbstractRegex(format);\r\n        return buildDateParseValuesMap(re);\r\n      }\r\n\r\n      function buildDateParseValuesMap (abstractRegex) {\r\n        var dateElements = Object.keys(regExpMap);\r\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\r\n        var valuesMatch;\r\n        var keyIndex;\r\n        var valueKey;\r\n        var valueFunction;\r\n        var valuesFunctionMap = [];\r\n\r\n        /* eslint-disable no-cond-assign */\r\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\r\n          keyIndex = valuesMatch[1];\r\n          valueKey = dateElements[keyIndex];\r\n          valueFunction = setFnMap[valueKey];\r\n\r\n          valuesFunctionMap.push(valueFunction);\r\n        }\r\n\r\n        return valuesFunctionMap;\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n"]}